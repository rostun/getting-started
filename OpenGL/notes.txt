WebGL Introduction.

WebGL is the web version of OpenGL. OpenGL is essentially an API that heavily interfaces with the graphics card drivers so in some ways 
its part of the drivers but in other ways its a library. You can see it as an API that lets you interact with the graphics hardware, 
similar to direct3d/directX. WebGL is basically the same as OpenGL ES, which is the version of OpenGL library that is used for mobile. 
They're almost the same thing but web version uses Javascript instead of c++ or Java or whatever language you use (They're both done by Kronos).
Also WebGL is a little easier to set up, since you can see your files in browser.

OpenGL Introduction. 

At the present time, OpenGL is the cross platform standard (direct3D is the microsoft standard, or some say directX) in how game engines are written 
(so follow this guide to get on that road to stardom!). If you're wondering why, let's go down history road. Way back in the olden days (24 years ago)
before the official release of OpenGL and the use of graphics hardware, games used to just have the CPU do all the graphics calculations, which is 
kind of inefficient for several reasons. First of all, this means that it's one more thing that the computer has to think about, which puts a severe 
limit on what you can do as well as a lot of stress on the CPU. While the CPU is actually pretty good at doing a lot of things at once (and pretty 
well) it doesn't do one specific thing well, or rather, the best. Sort of the whole jack of all trades but master of none. Or there's the whole thousand 
chickens vs the draft horse (David Luebke). So anyways, graphics hardware is good at calculating many pixels very fast (but again, does everything
else pretty poorly) so thus it quickly became the new standard, or "correct way" to draw things on the screen. 

Learn the first triangle, learn them all!

How it works:

	So how it basically works is that you have some vertices of something you want to draw (so a shape defined) and then you give that to OpenGL
	(so you tell OpenGL this is your data) and OpenGL will take your shaders that tells how you want to draw this data that you gave OpenGL.
	So then from there it takes this information you specified (shaders you used, vertices you've given it, etc) and it tells the pixels on the 
	screen what color to be. Essentially it converts triangles to pixels. 
	
	Why do you need to do this? Because although you understand vertices and OpenGL understands vertices, the screen doesn't. We call the space 
	in which you're drawing your vertices, the WorldSpace. Sort of like how when you model something in maya or Zbrush, your model exists in this 
	fake virtual space and that space has the position of the vertices in it. The screen we call ScreenSpace. 
	
	In more detail, to draw things you make use of two entities: the Vertex Array Object and the Vertex Buffer Object, which are both kind of like 
	pointers that hold different sorts of data. The VAO holds the state while the VBO holds the data for the verts. The data can be anything you want,

all you need is a body and canvas (where you draw), if the canvas element (ie8 or ie9 or anything before that)
is not supported it'll show. Basically if your browser is super old or on a weird device. Get with the program
dude!

1. in javascript you're going to need a global variable called GL. You can just declare it, but 
empty curly braces sets it to an object so you don't get undefined errors when you try to use it
when it doesn't exist yet. So it prevents null errors (well not exactly prevent, they'll just be silent)

2. //need some initialization function
//basically starting webgl
function initGL(){
	//"i want this canvas element to be a webgl canvas"
	//getting a reference to it, so now you have a variable you can manipulate
	//that is the OpenGL state
	//opengl is like a state machine so lets you manipulate this openGL state machine
	var canvas = document.getElementById("someID");

} 

3. The inspector will actually show WebGL failures. OpenGL just fails silently. WebGL still fails silently 
but then the browser tells you that it's failing silently.

4. trycatch block
	//JUST GENERallly good practice, you don't have to do it. the reason you do it
	// is if it fails you would want to handle it as oppposed to letting it get to 
	//the user. Even though you don't really handle it, just eat it/catch it and do 
	//nothing, you just want to make sure that if you get thrown an exception it gets 
	//handled some way (even if it's by doing nothing)
	try{
		//previously they did experimentally webgl, so if webgl fails you can go back 
		//to experimental web gl 
		// Try to grab the standard context. If it fails, fallback to experimental.
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"); 
	}

5. 
var gl = {}; //sets to an empty object, prevents null errors (they'll be silent)

//need some initialization function
//basically starting webgl
function initGL(){
	//get reference to canvas DOM Element
	var canvas = document.getElementById("someID");
	
	//try catch block
	try{
		// Try to grab the standard context. If it fails, fallback to experimental.
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"); 
	}
	catch(e){}
	
	//if we don't have a GL context, give up now 
	//if you can't get gl or it fails, there's a problem
	if(!gl){
		alert("unable to initialize webGL. Your browser might not support it.");
	}
	
	return gl;
} 

6. Alright so now lets make it be a color. 
var gl = {}; //sets to an empty object, prevents null errors (they'll be silent)

//need some initialization function
//basically starting webgl
function initGL(){
	//get reference to canvas DOM Element
	var canvas = document.getElementById("someID");
	
	//try catch block
	try{
		// Try to grab the standard context. If it fails, fallback to experimental.
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"); 
	}
	catch(e){}
	
	//if we don't have a GL context, give up now 
	//if you can't get gl or it fails, there's a problem
	if(!gl){
		alert("unable to initialize webGL. Your browser might not support it.");
	}
	

	if(gl){
		//set clear to black, sets every pixel to that color , whatever color you want
		gl.clearColor(0.0, 0.0, 0.0, 1.0); //what does a blank screen look like for me?
		//enable depth test: don't have to do the depth test
		//openGL makes it so that if you have things behind each other it'll draw it in the right order 
		gl.enable(gl.DEPTH_TEST);
		//set the depth function to <=
		gl.depthFunc(gl.LEQUAL); //when it compares two things, uses <=, can be >= whatever you want 
		//clear the color/depth buffers
		//this is you actually filling everything with the clear color, so that anything old in there
		//is no longer there. sort of like resetting memory in c back to 0
		//two bit flags, clear them
		//single pipe is a bitwise or (kind of like binary addition, there's no carrying)
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		//now i need to set the viewport, it tells openGL how big your drawing field is
		//in html do width 640 hieght 640
		gl.viewport(0,0, canvas.width, canvas.height);
	}
	return gl;
} 

<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<title>WebGL using Javascript</title>
		<script src="followAlong.js"></script>
	</head>
	<body onload="initGL()"> <!--actually javascript so need parantheses-->
		<canvas id="someID" width="640" height="480">
			Browser does not support the <code>&ltcanvas&gt</code> element.
		</canvas>
	</body>
</html>

//onload is a thing that has an anonymous function on it, all the events tag 

7. Now we have our drawing area, and we have to do a few chores before we get drawing 
--------------------------------------------------------------------------------
8. we need to set up our shaders, can't be in js file because it is not javascript 

if you really wanted to you could do it as a string in your function
//could just do one big string but it's not as readable
	->//can't use // in the middle of a string because javascript won't see that as an end line
	->//its interpreted language so the version below will work 
var fs = "prevision mediump float;" +  
"			varying vec4 oPosition;" + 
"			varying vec3 oNormal;" +
"			varyin vec2 oUv;" +			
"			void main(void){" +
"				gl_FragColor=(oPosition + 1.0) * 0.5;" +
"			}" ;

but we're going to just do it in html 
these shaders are in whats called GLSL, so its an opengl shading language that's similar to c
(we don't need normals or uvs since this is a beginners guide) ;)

so the vertex shader happens per vertex, while the fragment shader happens pretty much per pixel,
so the fragments are not actually 1 pixel, sometimes its multiple pixels per fragment or smaller. 
but you can think of it as a pixel shader. 

when you're passing a variable from vertex to fragment it linearly interpolates it, which means
if you have two vertices it will figure out the values in between linearly (it will assume there 
is a plain line in betwen those two and figure out the values in between) Makes it so that it's about
smooth straight gradient in betweeen them. A guess basically. So if you have two vertexes with two 
colors then it'll be a linear gradient. Vs a spherical interpolation which will be a different type of 
gradients. 

//varying keyword makes the vertex talk to fragmet 
//varying is output from vertex, but in fragment its input

<script id="shader-fs" type="x-shader/x-fragment">
	//specifies the floating point precision which is required, you need to put 
	//a precision of some kind for floats, so we're doing precision mediump
	precision mediump float;
	
	//going from vertex to shader 
	varying vec4 oPosition; 
	//varying vec3 oNormal;
	//varying vec2 oUv;
	
	//this is our main function, like in c, so everything we want to run 
	//has to be called in main 
	void main(void){
		//gl_FragColor is the final final output of our frag shader
		//telling the screen what color to be 
		//whole goal is to tell this thing I want this pixel to be this color 
		//its -1 to 1 but we want it to be 0 to 1
		gl_FragColor = (oPosition + 1.0) * 0.5; //basically a color (based on position)
	}
</script>
//entry point is vertex shader
//attribute is basically input position 
<script id="shader-vs" type="x-shader/x-vertex">

	//so your attribute variables are inputs to the vertex shader
	//so this is the thing we will be specifiying through opengl as a vertex array. 
	//so this is the position of the vertices 
	attribute vec3 position;
	//attribute vec3 normal;
	//attribute vec2 uv;
	
	//varying is kind of like a type, basically means its going from vertex to fragment
	//the varying is an output from the vertex shader 
	//and it's an input to the fragment shader 
	varying vec4 oPosition;
	//varying vec3 oNormal;
	//varying vec2 oUv;
	
	//so your uniforms are global variables for all the shaders
	//so the model view matric and the other is perspective matrix 
	//model view matrix lets you reposition your object, its how you move stuff around 

	uniform mat4 uMVMatrix;
	//uP is for camera view, later on this (we'll get a library) will let you do a perspective projection
	//when we do 2d in unity we turn this off
	uniform mat4 uPMatrix;
	
	//call stuff
	void main(void){
		//homogonous coordinates, making it from vec3 to vec4 
		oPosition = vec4(position, 1.0); //feeding stuff into fragment shader 
		//and the final output of the vertex shader is the gl_Position, 
		//which tells the vertex where it is. So what we're doing here
		//is we're modifying uPMatrix and uMVMatrix 
		gl_Position = uPMatrix * uMVMatrix * oPosition;
		//oNormal = normal;
		//oUv = uv;
	}
</script>

10. write the two shader functions getShader() and initShaders, but not mesh yet so still black
11. 	<script id="shader-vs" type="x-shader/x-vertex">
		//vertex array 
		attribute vec3 position;
		//output from the vertex shader 
		varying vec4 oPosition;
		//model view matrix (positioning in space of your vertex)
		//uniform mat4 uMVMatrix;
		//perspective matrix (camera)
		//uniform mat4 uPMatrix;
		
		void main(void){
			oPosition = vec4(position, 1.0);
			gl_Position = oPosition;
			//gl_Position = uPMatrix * uMVMatrix * oPosition;
			//oNormal = normal;
			//oUv = uv;
		}
	</script>
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;
		//input to the vertex shader 
		varying vec4 oPosition;
		
		void main(void){
			gl_FragColor = (oPosition + 1.0) * 0.5;
		}
	</script>
	
var gl = {}; //sets to an empty object, prevents null errors (they'll be silent)

//need some initialization function
//basically starting webgl
function initGL(){
	//get reference to canvas DOM Element
	var canvas = document.getElementById("someID");
	
	//try catch block
	try{
		// Try to grab the standard context. If it fails, fallback to experimental.
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl"); 
	}
	catch(e){}
	
	//if we don't have a GL context, give up now 
	//if you can't get gl or it fails, there's a problem
	if(!gl){
		alert("unable to initialize webGL. Your browser might not support it.");
	}

	if(gl){
		//set clear to black, sets every pixel to that color , whatever color you want
		gl.clearColor(0.0, 0.0, 0.0, 1.0); //what does a blank screen look like for me?
		//openGL makes it so that if you have things behind each other it'll draw it in the right order 
		gl.enable(gl.DEPTH_TEST);
		//set the depth function to <=
		gl.depthFunc(gl.LEQUAL); //when it compares two things, uses <=, can be >= whatever you want 
		//clear the color/depth buffers
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		//now i need to set the viewport, it tells openGL how big your drawing field is
		gl.viewport(0,0, canvas.width, canvas.height);
	}
	
	//initialize shaders 
	var program = initShaders();
	gl.useProgram(program);
	//gets you your variable posiiotn attribute location 
	var positionAttributeLocation = gl.getAttribLocation(program, "position");
	gl.enableVertexAttribArray(positionAttributeLocation); //this is the vertex shader variable
	//initilaize the buffers 
	var buffers = initBuffers();
	//groups of three, type, normalized? stride, offset 
	//stride: how many it skips
		//you can interweave the data so then in your array you ahve position then normal then uv all in one array
		//but here we only have position so our stride is 0 
	//offset: 0 (so if we had normal and uv then we have 6 normals, 6 uvs etc)
	gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
	
	//vertex buffer object, index buffer object 
	//binding those again before we draw
	//that specifies what we want to draw 
	gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vbo);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.ibo);
	
	//arguments: mode, number, type, offset
	//mode is how you want to draw it, it could be points, it could be lines, triangles, traignle strip, etc 
	//TRIANGLES: draw these unconnected triangles 
	//number: how many indices you are drawing (size of index array whihc is 6)
	//type: type of the number you are giving it, which is either unsigned byte or unsigned short (short is a 16 bit integer, other is 8)
	//offest: where you want to start in the array, but we're starting at the beginning which is 0
	gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	gl.drawArrays(gl.TRIANGLES, 0, 3);
	return gl;
} 

//new function that is the shader initialization
function initShaders(){
	//open gl provides these functions
	//gl object for the shader and program 
	//argument: what kind of shader do you want to create?
	var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);	
	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	//combination of vertex and fragment shaders 
	var shaderProgram = gl.createProgram();
	
	//specifying source code to the shader 
	gl.shaderSource(fragmentShader, getShader("shader-fs"));
	gl.shaderSource(vertexShader, getShader("shader-vs"));
	//attaching it to the shader program 
	gl.attachShader(shaderProgram, fragmentShader);
	gl.attachShader(shaderProgram, vertexShader);
	
	//need to compile shaders and check for errors 
	gl.compileShader(fragmentShader);
	//check if compiled successfully
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
		alert("Shader compilation for fragment shader failed.\n"
		+ gl.getShaderInfoLog(fragmentShader));
	}

	gl.compileShader(vertexShader);
	//check if compiled successfully
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
		alert("Shader compilation for fragment shader failed.\n"
		+ gl.getShaderInfoLog(vertexShader));
	}
	
	//next step is linking 
	gl.linkProgram(shaderProgram);
	if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)){
		alert("Linking program failed\n"
		+ gl.getProgramInfoLog(shaderProgram));
	}
	//return shaderProgram object 
	return shaderProgram;
}

//going to get it from DOM, right now its in a script tag we need to make it into a string 
//different from tutorial
//walks throuhg the element you just got and gets the text nodes
//example taking in shader-fs or shader-vs 
function getShader(name){
	var shaderScript, shaderSource, currentChild;
	//grabbing whatever name you inputted
	shaderScript = document.getElementById(name); //grab id
	//if it fails just returns null
	if(!shaderScript){
		return null;
	}
	
	shaderSource = "";
	currentChild = shaderScript.firstChild; 
	//go through the DOM tree
	while(currentChild){
		if(currentChild.nodeType == currentChild.TEXT_NODE){
			shaderSource += currentChild.textContent;
		}
		currentChild = currentChild.nextSibling;
	}
	//returns the string that is shaderSource
	return shaderSource;
}

function initBuffers(){
	//creates a vertex buffer object 
	//just an empty buffer, getting ready to hold stuff
	var quadBuffer = gl.createBuffer();
	
	//put stuff in it 
	//you're saying that this buffer is being bound to the openGL thing that is ARRAY_BUFFER 
	//other one is ELEMENT_ARRAY_BUFFER 
	//binding triBuffer to ARRAY_BUFFER 
	gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
	
	//specifying what the vertices are, position of triangle vertices  
	//set up geometry properly!
	//x y z
	//homogonous add 1, x y z w but w is always 1 becuase basically 
	//it lets you multiple the values with the matrix
	var vertices = [
		 1.0,  1.0, 0.0, //0
		-1.0,  1.0, 0.0, //1
		-1.0, -1.0, 0.0, //2
		 1.0, -1.0, 0.0  //3
	];
	
	//Float32Array is a typed array that just exists in javascript
	//creating an array out of the vertices we just made (vertex information) 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	
	//different from guide 
	//index geometry - allows you to reuse vertices 
	//for example a square is made of two triangles = 6 vertices with two vertices reused
	//this allows you to reference an existing vertex 
	var indexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	
	//two triangles, 2 1 0, and the second is 3 2 0 
	var indices = [2, 1, 0, 3, 2, 0]; //refrence vertices 
	
	//create array out of vertices we just made, this time giving index information 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
	
	//javascript shorthand for making an object 
	//two properties (vbo and ibo) which stores both buffer objects to return it 
	var buffers = {vbo:quadBuffer, ibo:indexBuffer};
	return buffers;
}

12. now we need to use two libraries 

this library is for matrix and vector math, makes things easier!
http://sylvester.jcoglan.com/
sylvester.js is the minified version, but i like to keep both for reading purposes ;)
	when things go wrong you can take a look at the function and see if you used it wrong 
utility functions for making [perspective] matrices and frustums (kind of like a four sided pyramid with the top cut off)
(whole thing is for making a perspective matrix)
its this math thing you need to make that, which isn't that interesting so we're going to use this thing 
we could just copy those, but they've done it already so there's really no need to rewrite the code, but you could 
if you want to, come back when you have 
https://github.com/mdn/webgl-examples/blob/gh-pages/tutorial/glUtils.js

		<script src="libraries/sylvester.js"></script>
		<script src="libraries/glUtils.js"></script>

13. before you draw we're gonna move things around a bit

remove draw arrays (no draw arrays ever) <--fo testing purposes if not doing index 
		
		void main(void){
			oPosition = vec4(position, 1.0);
			gl_Position = uMVMatrix * oPosition;
			//gl_Position = uPMatrix * uMVMatrix * oPosition;
			//oNormal = normal;
			//oUv = uv;
		}

